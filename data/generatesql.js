"use strict";
//all dictionaries are presumed to have a string as the value, otherwise, the sql generated will convert everything to a string in makeJoinTable()
const data = require("./RockAtoPierce.json");
const dataTables=require('./dataTables.json');
const prefixOrSuffix=require("./prefixOrSuffix.json");
let sql='';
let dictionaries=[];
let joinTables=[];
const writeFileSync = require("fs").writeFileSync;

dataTables.forEach(dataTable=>{
    sql+='CREATE TABLE `'+dataTable.name+'` (';
    switch(dataTable.type){
        case "dictionary": //the primary key is the columnName because that is what will be searched. Then the i will be used to find the id, then the ID to find all other data
            sql+="`i` smallint UNSIGNED NOT NULL UNIQUE,\n\
            `"+dataTable.columnName+"` varchar(250) NOT NULL UNIQUE,\n\
            PRIMARY KEY(`"+dataTable.columnName+"`));";
            dictionaries.push([dataTable.name,dataTable.columnName]);
            break;
        case "join":
            sql+="`id` smallint UNSIGNED NOT NULL,\n\
            `fk_"+dataTable.dictionary+"` smallint UNSIGNED NOT NULL,\n\
            PRIMARY KEY(`id`,`fk_"+dataTable.dictionary+"`));";
            break;
        case "independent":
            sql+="`id` smallint UNSIGNED NOT NULL,\n\
            `"+dataTable.name+"` "+dataTable.datatype+" NOT NULL,\n\
            PRIMARY KEY(`id`,`"+dataTable.name+"`));";
            break;
        default: throw new Error(dataTable.type+" is an invalid value for the 'type' key.");
    }
})
sql+=(require('./json2sql.js'))(data, dataTables, prefixOrSuffix);
writeFileSync("data/generatedsql/freshsql.sql", sql); //this runs when the last dictionary has been added







/* 

//* *this is the new data to be added. 
This json should be generated by getting a csv from the "Cemetery Staging" sheet and then selecting hash at https://csvjson.com/csv2json
result should look like this
{
   "0": {
     "last_name": "ALLEN", 
	 [...]
const escapedor = "|or|"; //this will be replaced with "or", but unlike an " or " literal, won't cause a separation into two possibilities.
const dataTables=require('./dataTables.json');
dataTables.forEach
const XMLHttpRequest = require("xhr2");
let dictionaries = {};
let xhrs = [];
dictionaryNames.forEach((dictionaryName, i) => {
	xhrs[i] = new XMLHttpRequest();
	xhrs[i].myDictionaryName = dictionaryName;
	xhrs[i].myIteratorValue = i; //these allow me to pass parameters to the callback
	xhrs[i].onload = saveResponse;
	//xhrs[i].open("GET", "https://mocki.io/v1/d4867d8b-b5d5-4a48-a4ab-79131b5809b8"); //just so i don't flood the server, but can get to the calllback
	xhrs[i].open("GET", "https://dev.findagravemiddleborough.ml/data/dictionaries.php?dictionary=" + dictionaryName);
	xhrs[i].send();
});
function saveResponse() {
	let dictionaryName = this.myDictionaryName;
	let i = this.myIteratorValue;
	dictionaries[dictionaryName] = JSON.parse(this.responseText);
	if (i + 1 === dictionaryNames.length) {
        let initDB='';
        dataTables.forEach(v=>initDB+'CREATE TABLE `'+v+'`')
		let newData = require('./json2sql.js')(dataJSON,dictionaries,joinTables,dataTables,prefixOrSuffix);
		writeFileSync("data/generatedsql/RockCemeteryAtoPierce.sql", newData); //this runs when the last dictionary has been added
	}
} */